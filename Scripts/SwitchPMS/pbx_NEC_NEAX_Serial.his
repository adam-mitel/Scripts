; Coded For: 50.0.0.1
; Script Version: 50.0.0.2
; ************************************************************************
;
;  This is the HI configuration script for interfacing to an 
;  NEC NEAX 7400 ICS telephone exchange.
;
;  Maid Status Codes from this PBX:
;
;  Code -  Spec Description (Tiger Description)
;    1  -  Cleaning necessary (Vacant Dirty)
;    2  -  Room is cleaned (Vacant Clean)
;    3  -  Room is ready for reservation (Vacant Inspected?)
;    4  -  Room out of service (?)
;    5  -  Room needs repair (?)
;    6  -  Room is repaired (?)
;
;  Protocol defined by document:
;
;    Title:      NEAX7400 ICS Model 120 PMS System Manual
;    Revision:   Issue 1 (July, 1994)
;
;  Version 1.0                                                 pjh-170502
;
;  Modifications - AU - 10/11/2013
;	* Modified incoming Room Status events to strip any * or # characters which
;	  was causing our program to crash
;
;  Modifications - AU - 17/10/2013
;	* Updated to utilise V50 specific features
;
; ************************************************************************
;                     Copyright © 2013, TigerTMS Ltd.                     
; ************************************************************************

; Configuration Variables

define MaxEnqTries		// Max number of times to send enquiry.
define MaxRecTries		// Max number of times to send record.
define MaxNakCount		// Max number of NAKs before restarting link.
define DoSMDRPassThru		// Should we passthru SMDR to Data Collection
define DoWakeups		// Specify if we do Wakeup Calls


; Internal Variables

define fEnqCount		// Counts the number of times we send the enquiry.
define fRecCount		// Counts the number of times we send the record.
define fNakCount		// Counts the number of NAKs we receive.
define SendRec			// Stores our record to send.
define WorkVal			// Temporary working variable
define RecType			// Stores Record Type

; Input variables

define ReceivedRec		// Stores the received record.
define inFeatureCode	// Stores Feature Code from incoming record.
define inMsgCounter		// Stores Message Counter from incoming record.
define inFunctionCode	// Stores Function Code from incoming record.
define inStatus			// Stores Maid Status from incoming record.
define inExtn			// Stores Extension number from incoming record.
define inMaidID			// Stores Maid ID from incoming record.
define inWakeupTime		// Stores Wakeup Time from incoming record.
define inWakeupResult	// Stores Wakeup Result from incoming record.
define inBCC			// Stores BCC from incoming record.

; ************************************************************************
;  INIT
;   This part of the script is run once at the program start-up
; ************************************************************************
:INIT

  // OPT: Set here the maximum number of enquiries we will send without
  //      reply before releasing the data link.
  //      The default value is 16 (as defined in the protocol document)
  Assign MaxEnqTries 16

  // OPT: Set here the maximum number of times we will resend a record
  //      without reply before we release the data link and retry.
  //      The default value is 32 (as defined in the protocol document)
  Assign MaxRecTries 32

  // OPT: Set here the maximum number of NAKs we can receive to either
  //      a record or enquiry before we release the data link and retry.
  //      The default value is 4 (as defined in the protocol document)
  Assign MaxNakCount 4

  // OPT: Set this to "TRUE" if we should pass SMDR records through to
  //      data collection. This should only be set to "TRUE" if we are
  //      not handling SMDR through a seperate port.
  Assign DoSMDRPassThru "FALSE"

  // Specify if we do Wakeups
  // OPT: Options are "YES" and "NO"
  Assign DoWakeups "NO"

  ; Open the COM port
  OpenPort

Exit
; ************************************************************************

; ************************************************************************
;  CallRecord
;   The script is executed from this label when we have a call record to
;   send.
; ************************************************************************
:CallRecord

goto IgnoreRecord
; ************************************************************************

; ************************************************************************
;  Checkin
;   The script is executed from this label when we have a check in event
;   to send.
; ************************************************************************
:Checkin

  // OPT: If for some, unlikely, reason we do not wish to send checkin
  //      details to the PBX then uncomment the following line
  ;Goto IgnoreRecord
  
  ; Create the record.
  Assign SendRec "1!L1634B<_EV_EXTNNUMBER:TEXT:4:LJ,SP>        <_EV_CILANGCODE:TEXT:1:LJ,ZP>1<_EV_NAMEDISPLAY:TEXT:15:AN,LJ,SP><#3>"

  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"
  
  ; Send the Record
  Call SendRecord
  
goto HandleOKAndExit
; ************************************************************************

; ************************************************************************
;  Checkout
;   The script is executed from this label when we have a check out event
;   to send.
; ************************************************************************
:Checkout

  // OPT: If for some, unlikely, reason we do not wish to send checkout
  //      details to the PBX then uncomment the following line
  ;Goto IgnoreRecord

  ; Create the record.
  Assign SendRec "1!L16112<_EV_EXTNNUMBER:TEXT:4:LJ,SP>  <#3>"

  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"
  
  ; Send the Record
  Call SendRecord
  
goto HandleOKAndExit
; ************************************************************************

; ************************************************************************
;  ClassOfService
;   The script is executed from this label when we have a class of service
;   event to send.
; ************************************************************************
:ClassOfService

  // OPT: If for some, unlikely, reason we do not wish to send class of
  //      service changes to the PBX then uncomment the following line
  ;Goto IgnoreRecord

  ; Work out the Restriction Level.
  if "$(_EV_COSALLOWOUTGOING)" EQ "TRUE"
    Assign WorkVal "0"
  if "$(_EV_COSALLOWOUTGOING)" NE "TRUE"
    Assign WorkVal "1"
  
  ; Create the record.
  Assign SendRec "1!L15141<_EV_EXTNNUMBER:TEXT:4:LJ,SP>  <WorkVal:TEXT:1:LJ,ZP>  <#3>"
  
  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"
  
  ; Send the Record
  Call SendRecord
  
goto HandleOKAndExit
; ************************************************************************

; ************************************************************************
;  RoomUpdate
;   The script is executed from this label when we have a room update
;   event to send.
; ************************************************************************
:RoomUpdate

  // OPT: If for some, unlikely, reason we do not wish to send room
  //      updates to the PBX then uncomment the following line
  ;Goto IgnoreRecord

  ; Create the record.
  Assign SendRec "1!L21266<_EV_EXTNNUMBER:TEXT:4:LJ,SP>  <_EV_NAMEDISPLAY:TEXT:15:AN,LJ,SP><#3>"
  
  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"
  
  ; Send the Record
  Call SendRecord
  
goto HandleOKAndExit
; ************************************************************************

; ************************************************************************
;  RoomTransfer
;   The script is executed from this label when we have a room transfer
;   event to send.
; ************************************************************************
:RoomTransfer

  // OPT: If for some, unlikely, reason we do not wish to room transfers
  //      to the PBX then uncomment the following line
  ;Goto IgnoreRecord

  ; Create the record.
  Assign SendRec "1!L20171<_EV_EXTNNUMBER:TEXT:4:LJ,SP>  <_EV_TRDESTEXTNNUMBER:TEXT:4:LJ,SP>  <#3>"
  
  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"
  
  ; Send the Record
  Call SendRecord
  
goto HandleOKAndExit
; ************************************************************************

; ************************************************************************
;  RoomStatus
;   The script is executed from this label when we have a room status
;   event to send.
; ************************************************************************
:RoomStatus

goto IgnoreRecord
; ************************************************************************

; ************************************************************************
;  Minibar
;   The script is executed from this label when we have a minibar event
;   to send.
; ************************************************************************
:Minibar

goto IgnoreRecord
; ************************************************************************

; ************************************************************************
;  MessageWaiting
;   The script is executed from this label when we have a message waiting
;   event to send.
; ************************************************************************
:MessageWaiting

goto IgnoreRecord
; ************************************************************************

; ************************************************************************
;  WakeupCall
;   The script is executed from this label when we have a wakeup call
;   event to send.
; ************************************************************************
:WakeupCall

  if "$(DoWakeups)" NE "YES"
  	goto IgnoreRecord

  ; Check the action and perform the relevant command.
  if "$(_EV_WKACTION)" EQ "CLEAR"
    goto WakeupCallClear
  if "$(_EV_WKACTION)" EQ "CLEARALL"
    goto WakeupCallClear
  if "$(_EV_WKACTION)" EQ "SET"
    goto WakeupCallSet

  ; We haven't catered for this event so we'll exit.
  Goto WakeupCallDone
  
:WakeupCallClear
  ; We should be clearing a wakeup call

  ; Create the record.
  Assign SendRec "1!L19165<_EV_EXTNNUMBER:TEXT:4:LJ,SP>  00004<#3>"
  
  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"
  
  ; Send the Record
  Call SendRecord

  ; We're done.
  goto WakeupCallDone
  
:WakeupCallSet
  ; We should be setting a wakeup call
  
  ; Create the record.
  Assign SendRec "1!L19164<_EV_EXTNNUMBER:TEXT:4:LJ,SP>  <_EV_WKTIME:TIME:4:HHMM>4<#3>"
  
  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"
  
  ; Send the Record
  Call SendRecord

:WakeupCallDone

goto HandleOKAndExit
; ************************************************************************

; ************************************************************************
;  BudgetLimit
;   The script is executed from this label when we have a budget limit
;   event to send.
; ************************************************************************
:BudgetLimit

goto IgnoreRecord
; ************************************************************************

; ************************************************************************
;  ExtraGuest
;   The script is executed from this label when we have an extra guest
;   event to send.
; ************************************************************************
:ExtraGuest

goto IgnoreRecord
; ************************************************************************

; ************************************************************************
;  DoNotDisturb
;   The script is executed from this label when we have a do not disturb
;   event to send.
; ************************************************************************
:DoNotDisturb

goto IgnoreRecord
; ************************************************************************

; ************************************************************************
;  PIN
;   The script is executed from this label when we have a set or clear pin
;   event to send.
; ************************************************************************
:PIN

goto IgnoreRecord
; ************************************************************************

; ************************************************************************
;  DDI
;   The script is executed from this label when we have a set or clear ddi
;   event to send.
; ************************************************************************
:DDI

goto IgnoreRecord
; ************************************************************************

; ************************************************************************
;  PeriodicCheck
;   Execution is periodically carried out from here by the program to
;   handle periodic events.
; ************************************************************************
:PeriodicCheck

  ; Send a status enquiry
  Assign SendRec "1!L7007F  <#3>"

  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"

  ; Send the record.
  Call SendRecord
  
Exit
; ************************************************************************

; ************************************************************************
;  CheckIncoming
;   Execution is periodically carried out from here by the program to
;   check for incoming data during idle times.
; ************************************************************************
:CheckIncoming

  ; Read a character
  ReadFromPort 1
  
  If "$(_PORTCHARS)" EQ ""
    Goto NothingToReceive

  ; If it's a 1 then we need to handle an enquiry.
  If "$(_PORTCHARS)" EQ "1"
    Assign ReceivedRec "1"
  If "$(_PORTCHARS)" EQ "1"
    Goto ReceiveEnquiry

  ; If it's an STX then we should record it and goto ReceiveRecord
  If "$(_PORTCHARS)" EQ "<#2>"
    Assign ReceivedRec "<#2>"
  If "$(_PORTCHARS)" EQ "<#2>"
    Goto ReceiveRecord

  ; If it's an ENQ then we have failed to respond to a message 
  ; (probably because it was lost) so we'll send a NAK.
  If "$(_PORTCHARS)" EQ "<#5>"
    Echo Rx: $(_PORTCHARS)
  If "$(_PORTCHARS)" EQ "<#5>"
    Call SENDNAK
  If "$(_PORTCHARS)" EQ "<#5>"
    Goto NothingToReceive
          
  ; Otherwise just echo it and exit.
  Echo Rx: $(_PORTCHARS)

:NothingToReceive
Exit
; ************************************************************************

; ************************************************************************
;  ReceiveEnquiry
;   The script reaches this point when we receive a "1" character whilst
;   idle. We need to read the rest of the enquiry sequence and send an
;   ACK before calling ReceiveRecord.
;   (ReceivedRec will contain "1" )
; ************************************************************************
:ReceiveEnquiry

  ; Read the '!'
  ReadFromPort 1 1
  Assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"
  
  ; If it's not a '!' then echo what we've received and exit.
  if "$(_PORTCHARS)" NE "!"
    Echo Rx: $(ReceivedRec)
  if "$(_PORTCHARS)" NE "!"
    Goto InvalidData
    
  ; Read the ENQ
  ReadFromPort 1 1
  Assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"

  ; If it's not an ENQ then echo what we've received and exit.
  if "$(_PORTCHARS)" NE "<#5>"
    Echo Rx: $(ReceivedRec)
  if "$(_PORTCHARS)" NE "<#5>"
    Goto InvalidData

  ; We've received a complete enquiry sequence so echo it to comms 
  ; display.
  Echo Rx: $(ReceivedRec)
  
  ; If it's an Enquiry
  ; Send the ACK
  call SENDACK

  StartWaitTimer 10

:ReceiveENQ_WaitForSTX

  ReadFromPort 1

  if "$(_PORTCHARS)" EQ "<#2>"
    Assign ReceivedRec "<#2>"
  if "$(_PORTCHARS)" EQ "<#2>"
    Call ReceiveRecord

  if "$(_WAITTIMEEXPIRED)" EQ "TRUE"
    Echo "Er: Timeout waiting for record.
  if "$(_WAITTIMEEXPIRED)" EQ "TRUE"
    Goto InvalidData

  Goto ReceiveENQ_WaitForSTX
  
:InvalidData
  ; Terminate script.
Exit
; ************************************************************************

; ************************************************************************
;  ReceiveRecord
;   Execution is sent here when we have received an enquiry sequence from
;   the PBX. The Enquiry sequence has already been dealt with so we need
;   to get the record in and deal with it.
;   (ReceivedRec will contain "<STX>")
; ************************************************************************
:ReceiveRecord

  ; Read the next 3 characters from the port.. These should be the
  ; System Address, Unit Address and Entry Index
  ReadFromPort 3 2
  
  ; If it's not blank then add it to the record
  if "$(_PORTCHARS)" NE ""
    assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"

  ; If it is blank then go back and read again.
  if "$(_PORTCHARS)" EQ ""
    Goto ReceiveRecord

:ReadFeatureCode
  
  ; Read the next 2 characters from the port.. This should be the 
  ; feature code.
  ReadFromPort 2 2
  
  ; If it's not blank then add it to the record
  if "$(_PORTCHARS)" NE ""
    assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"
  if "($_PORTCHARS)" NE ""
    assign inFeatureCode "$(_PORTCHARS)"

:ReadMessageCount

  ; Read the next 2 characters from the port.. This should be the 
  ; message counter.
  ReadFromPort 2 2
  
  ; If it's not blank then add it to the record
  if "$(_PORTCHARS)" NE ""
    assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"
  if "($_PORTCHARS)" NE ""
    assign inMsgCounter "$(_PORTCHARS)"

:ReadFunctionCode

  ; Read the next 2 characters from the port.. This should be the 
  ; message counter.
  ReadFromPort 1 1
  
  ; If it's not blank then add it to the record
  if "$(_PORTCHARS)" NE ""
    assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"
  if "($_PORTCHARS)" NE ""
    assign inFunctionCode "$(_PORTCHARS)"

  ; Set up a wait timer so we can timeout if we don't get the rest of the
  ; record
  StartWaitTimer 10

:ContinueReceiving

  ; Read from port.
  ReadFromPort 1
  
  if "$(_WAITTIMEEXPIRED)" EQ "TRUE"
    goto TimeoutReceiving

  ; If we have received a character then add it to our record.
  If "$(_PORTCHARS)" NE ""
    Assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"

  ; If we have an ETX we should move onto reading the BCC.
  If "$(_PORTCHARS)" EQ "<#3>"    
    goto ReadBCC

  ; Keep on reading.
  goto ContinueReceiving

:TimeoutReceiving

  ; We have timed out receiving part way through a record. We should junk 
  ; what we have and send nothing, the PBX will send ENQ.
  Echo Er: Timed out waiting for record.
  
  ; Go back to idle state.
  Exit
  
:ReadBCC

  ReadFromPort 1 2

  ; If there's no characters then tack a NULL on the end.  
  If "$(_PORTCHARS)" EQ ""
    Assign ReceivedRec "$(ReceivedRec)" + "<#0>"
    
  ; If there was a character then add it on.
  If "$(_PORTCHARS)" NE ""
    Assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"

  ; By this point we have a complete record, so we need to process it
  ; depending on the Feature Code.
  If "$(inFeatureCode)" EQ "11"
    Call MAIDSTATUS_GUESTROOM
  If "$(inFeatureCode)" EQ "12"
    Call MAIDSTATUS_PREDEFINED
;  If "$(inFeatureCode)" EQ "13"
;    Call MW_RECORD
  If "$(inFeatureCode)" EQ "14"
    Call SMDR_RECORD
  If "$(inFeatureCode)" EQ "19"
    Call WAKEUP_RECORD
  If "$(inFeatureCode)" EQ "70"
    Call STATUS_RECORD

  ; Echo record to screen
  Echo Rx: $(ReceivedRec)

  ; Send an ACK back
  Call SENDACK

  ; We should now have a RecType set, if not it's not a record we're 
  ; interested in.
  Echo Rectype = "$(RecType)"
  
  If "$(RecType)" EQ ""
    Goto SkipProcessIncoming

  ; We have a valid record so let's parse it.
  Assign _G_IN_RECORD "$(ReceivedRec)"
  ParseInRecord
  
  ; If we encountered an error then report it.
  If "$(_G_IN_RECORDPARSEERROR)" EQ "TRUE"
    Call ReceiveError

  ; If it's a Maid Status record then handle it.
  if "$(RecType)" EQ "RS"
    Call HandleMaidStatus
;  if "$(RecType)" EQ "MW"
;    Call HandleMessageWaiting
  if "$(RecType)" EQ "SMDR"
    Call HandleSMDR
  if "$(RecType)" EQ "WK"
    Call HandleWakeup
  if "$(RecType)" EQ "ST"
    Call HandleStatus
        
:SkipProcessIncoming

Exit
; ************************************************************************

; ************************************************************************
;  ReceiveError
;    Sent here when an error is found in the formatting of the record.
; ************************************************************************
:ReceiveError
  Echo Error with Received Record - Record ignored
Return
; ************************************************************************

; ************************************************************************
;  MAIDSTATUS_GUESTROOM
;   Set up for receiving a Maid Status event originating from a guest
;   room.
; ************************************************************************
:MAIDSTATUS_GUESTROOM

  ; Assign the record type.
  Assign RecType "RS"
	
  ; Assign the record format.	
  AssignAsIs _G_IN_RECORDFORMAT "<#2>1!L1117<inStatus:TEXT:1:LJ,ZP><inExtn:TEXT:6:LJ,ZP>  <inMaidID:TEXT:2:LJ,ZP>    <#3><inBCC:TEXT:1:LJ,SP>"

Return	
; ************************************************************************

; ************************************************************************
;  MAIDSTATUS_PREDEFINED
;   Set up for receiving a Maid Status event originating from a front
;   desk console.
; ************************************************************************
:MAIDSTATUS_PREDEFINED

  ; Assign the record type.
  Assign RecType "RS"
	
  ; Assign the record format.
  AssignAsIs _G_IN_RECORDFORMAT "<#2>1!L1217<inStatus:TEXT:1:LJ,ZP><inExtn:TEXT:4:LJ,ZP>  <inMaidID:TEXT:2:LJ,ZP>    <#3><inBCC:TEXT:1:LJ,SP>"

Return	
; ************************************************************************

; ************************************************************************
;  MW_RECORD
;   Set up for receiving a Message Waiting event from the PBX.
; ************************************************************************
:MW_RECORD

  ; Assign the record type.
  Assign RecType "MW"
	
  ; Assign the record format.
  AssignAsIs _G_IN_RECORDFORMAT "<#2>1!L1311<inStatus:TEXT:1:LJ,ZP><inExtn:TEXT:4:LJ,ZP>  <#3><inBCC:TEXT:1:LJ,SP>"

Return	
; ************************************************************************

; ************************************************************************
;  SMDR_RECORD
;   Set up for receiving a SMDR record
; ************************************************************************
:SMDR_RECORD

  ; Assign the record type.
  Assign RecType "SMDR"

  ; Not fussed about record format since this will just get piped out to
  ; data collection via the DCPassThru mechanism.
  
Return
; ************************************************************************

; ************************************************************************
;  WAKEUP_RECORD
;   Set up for receiving a Wakeup record
; ************************************************************************
:WAKEUP_RECORD

  ; Assign the record type.
  Assign RecType "WK"

  ; Assign the record format.
  AssignAsIs _G_IN_RECORDFORMAT "<#2>1!L1916<inStatus:TEXT:1:LJ,ZP><inExtn:TEXT:4:LJ,ZP>  <inWakeupTime:TEXT:4:LJ,ZP><inWakeupResult:TEXT:1:LJ,ZP><#3><inBCC:TEXT:1:LJ,SP>"

Return
; ************************************************************************

; ************************************************************************
;  STATUS_RECORD
;   Set up for receiving a Link Status record
; ************************************************************************
:STATUS_RECORD

  ; Assign the record type.
  Assign RecType "ST"

  ; Assign the record format.
  AssignAsIs _G_IN_RECORDFORMAT "<#2>1!L7007<inStatus:TEXT:1:LJ,ZP>  <#3><inBCC:TEXT:1:LJ,SP>"

Return
; ************************************************************************

; ************************************************************************
;  HandleMaidStatus
;   Execution is sent here whenever we receive a Maid Status message from
;   the PBX.
; ************************************************************************
:HandleMaidStatus

; Strip any * or #
  ReplaceStr "$(inStatus)" "*" "" "TRUE" "FALSE"
  Assign inStatus "$(_G_RESULT)"
  ReplaceStr "$(inStatus)" "#" "" "FALSE" "TRUE"
  Assign inStatus "$(_G_RESULT)"

  ; Create the event if it's not blank
  if "$(inStatus)" NE ""
    CreateRoomStatus "$(inExtn)" "$(inStatus)"

  ; Echo if it's blank
  if "$(inStatus)" EQ ""
    Echo Er: Skipping Room Status with invalid character
  
Return
; ************************************************************************

; ************************************************************************
;  HandleMessageWaiting
;   Execution is sent here whenever we receive a Message Waiting message
;   from the PBX.
; ************************************************************************
:HandleMessageWaiting

  ; Make sure we have a Status.
  Assign WorkVal "FALSE"
  If "$(inStatus)" EQ "1"
    Assign WorkVal "TRUE"

  ; Create the event.
  CreateMessageWaiting "$(inExtn)" "$(WorkVal)"
  
Return
; ************************************************************************

; ************************************************************************
;  HandleWakeup
;   Execution is sent here whenever we receive a Wakeup message from
;   the PBX.
; ************************************************************************
:HandleWakeup

  ; Make sure we have a Status.
  If "$(inStatus)" EQ "1"
    Goto HandleWakeup_Set
  If "$(inStatus)" EQ "2"
    Goto HandleWakeup_Cancel
  If "$(inStatus)" EQ "3"
    Goto HandleWakeup_Result

  ; Done with this message
  Goto HandleWakeup_Done

:HandleWakeup_Set
  
  ; Create the event.
  CreateSetWakeup "$(inExtn)" "" "<inWakeupTime:TIME:4:HHMM>"

  ; Done with this message
  Goto HandleWakeup_Done
  
:HandleWakeup_Cancel

  ; Create the event.
  CreateClearAllWakeup "$(inExtn)" ""

  ; Done with this message
  Goto HandleWakeup_Done

:HandleWakeup_Result

  ; Default message
  Assign WorkVal ""
  
  ; Check the result and display appropriate message
  If "$(inWakeupResult)" EQ "1"
     Assign WorkVal "Wakeup call for $(inWakeupTime) on extn $(inExtn) answered"

  If "$(inWakeupResult)" EQ "2"
     Assign WorkVal "Wakeup call for $(inWakeupTime) on extn $(inExtn) failed because the line was busy"

  If "$(inWakeupResult)" EQ "3"
     Assign WorkVal "Wakeup call for $(inWakeupTime) on extn $(inExtn) failed because there was no answer"
     
  If "$(inWakeupResult)" EQ "4"
     Assign WorkVal "Wakeup call for $(inWakeupTime) on extn $(inExtn) failed because it was blocked"

  If "$(WorkVal)" NE ""
     Echo "$(WorkVal)"

  ; Done with this message
  Goto HandleWakeup_Done

:HandleWakeup_Done
Return
; ************************************************************************

; ************************************************************************
;  HandleStatus
;   Execution is sent here whenever we receive a Link Status message from
;   the PBX.
; ************************************************************************
:HandleStatus

  ; Check the function code and perform relevant action.
  
  ; If it's a no changes response then we're done here.
  If "$(inStatus)" EQ "0"
    Goto HandleStatus_Done
  
  ; If it's a changes made response then we need to do a DB swap.
  If "$(inStatus)" EQ "2"
    Goto HandleStatus_DBSwap
    
  ; If it's a confirmation of link release then not sure how we got it.
  ; but we should probably ignore it anyway.
  If "$(inStatus)" EQ "6"
    Goto HandleStatus_ConfirmRelease
    
:HandleStatus_DBSwap

  ; Send a start db swap message
  Assign SendRec "1!L70073  <#3>"

  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"

  ; Send the record.
  Call SendRecord

  ; Send a finish db swap message
  Assign SendRec "1!L70074  <#3>"

  ; Generate the BCC
  GenerateBCCChar "" "$(SendRec)"
  Assign SendRec "<#2>$(SendRec)$(_G_BCC)"

  ; Send the record.
  Call SendRecord

  Goto HandleStatus_Done
  
:HandleStatus_ConfirmRelease

  ; Do nothing
  
:HandleStatus_Done
Return
; ************************************************************************

; ************************************************************************
;  HandleSMDR
;   Execution is sent here whenever we receive an SMDR message from
;   the PBX.
; ************************************************************************
:HandleSMDR

  ; Create the event.
  if "$(DoSMDRPassThru)" EQ "TRUE"
    PassToDataCollection $(ReceivedRec)
  
Return
; ************************************************************************

; ************************************************************************
;  SendRecord
;   Execution is sent here whenever we have a record in SendRec to send
;   to the PBX.
; ************************************************************************
:SendRecord

  ; Reset counters
  Assign fEnqCount 0
  Assign fRecCount 0
  Assign fNakCount 0

:ResendEnquiry

  ; If we've hit our max retries then we should abort sending and send
  ; an EOT.
  if "$(fEnqCount)" GT "$(MaxEnqTries)"
    Echo Max enquiries sent.. Sending EOT..
  if "$(fEnqCount)" GT "$(MaxEnqTries)"
	goto AbortSending

  ; If we've hit our max NAK count then we should abort sending and send
  ; an EOT.
  if "$(fNakCount)" GT "$(MaxNakCount)"
    Echo Max NAKs received.. Sending EOT..
  if "$(fNakCount)" GT "$(MaxNakCount)"
	goto AbortSending

  ; Send an Enquiry (Request to send) sequence.
  Call SENDENQUIRY

  ; Count our EnqRetries.
  Assign fEnqCount $(fEnqCount) + 1

  ; Setup a wait timer for 5 seconds.
  StartWaitTimer 5

:WaitForAckToEnq

  ; Wait for ACK to our Enquiry.
  ReadFromPort 1

  ; If it's an ENQ then we have failed to respond to a message 
  ; (probably because it was lost) so we'll send a NAK.
  If "$(_PORTCHARS)" EQ "<#5>"
    Echo Rx: $(_PORTCHARS)
  If "$(_PORTCHARS)" EQ "<#5>"
    Call SENDNAK
  If "$(_PORTCHARS)" EQ "<#5>"
    goto ResendEnquiry

  ; If it's an ACK then move onto Phase 2.
  If "$(_PORTCHARS)" EQ "<#6>"
    Echo Rx: $(_PORTCHARS)
  If "$(_PORTCHARS)" EQ "<#6>"
    Goto GotAckToEnq

  ; If it's a DLE then we should handle the data link escape and relinquish 
  ; the data link.
  If "$(_PORTCHARS)" EQ "<#16>"
    Assign ReceivedRec "<#16>"
  If "$(_PORTCHARS)" EQ "<#16>"
    Goto HandleDLE
  
  ; If it's a NAK then we should increment our NAK count and resend the 
  ; Enquiry sequence.
  If "$(_PORTCHARS)" EQ "<#21>"
    Echo Rx: $(_PORTCHARS)
  If "$(_PORTCHARS)" EQ "<#21>"
  	Assign fNakCount $(fNakCount) + 1
  If "$(_PORTCHARS)" EQ "<#21>"
    Goto ResendEnquiry
    
  ; If it's a '1' then the other system is trying to send us an Enquiry
  ; sequence so we should hop off and handle that.
  If "$(_PORTCHARS)" EQ "1"
    Assign ReceivedRec "$(_PORTCHARS)"
  If "$(_PORTCHARS)" EQ "1"
    Goto HandleEnquiry

  ; If it's none of the above then just print it.
  If "$(_PORTCHARS)" NE ""
    Echo Rx: $(_PORTCHARS)
    
  ; If we've received no reply then we should resend the enquiry sequence.
  If "$(_WAITTIMEEXPIRED)" EQ "TRUE"
    Echo Er: Timeout waiting for ACK to Enquiry
  If "$(_WAITTIMEEXPIRED)" EQ "TRUE"
    Goto ResendEnquiry
    
  Goto WaitForAckToEnq
  
:GotAckToEnq

  ; Reset NAK count
  Assign fNakCount 0
  Assign fRecCount 0
  
:ResendRecord

  ; If we've hit our max NAK count then we should abort sending and send
  ; an EOT.
  if "$(fNakCount)" GT "$(MaxNakCount)"
	goto AbortSending

  ; Send our record.
  Send $(SendRec)
  Echo Tx: $(SendRec)

  ; Setup a wait timer for 10 seconds.
  StartWaitTimer 10

  ; Wait for the ACK.
  Goto WaitForAckToRec
 
:SendEnqForReply

  ; If we've hit our max retries then we should abort sending and send
  ; an EOT.
  if "$(fRecCount)" GT "$(MaxRecTries)"
	goto AbortSending

  ; Send an ENQ to ask for a reply.
  Call SENDENQ
  
  ; Increment our counter.
  Assign fRecCount $(fRecCount) + 1

  ; Reset our wait timer for 10 seconds.
  StartWaitTimer 10
  
:WaitForAckToRec

  ; Wait for ACK to our record.
  ReadFromPort 1

  ; If we've received an ACK then we can move on to Phase 3.  
  If "$(_PORTCHARS)" EQ "<#6>"
    Echo Rx: $(_PORTCHARS)
  If "$(_PORTCHARS)" EQ "<#6>"
    Goto GotAckToRec

  ; If it's a DLE then we should handle the data link escape and relinquish
  ; the data link.
  If "$(_PORTCHARS)" EQ "<#16>"
    Assign ReceivedRec "<#16>"
  If "$(_PORTCHARS)" EQ "<#16>"
    Goto HandleDLE

  ; If it's a NAK then we should increment the NAK count and resend 
  ; the message.
  If "$(_PORTCHARS)" EQ "<#21>"
    Echo Rx: $(_PORTCHARS)
  If "$(_PORTCHARS)" EQ "<#21>"
    Assign fNakCount $(fNakCount) + 1
  If "$(_PORTCHARS)" EQ "<#21>"
    Goto ResendRecord

  ; If it's none of the above then just print it.
  If "$(_PORTCHARS)" NE ""
    Echo Rx: $(_PORTCHARS)

  ; If we've received no reply then we should send an ENQ character.
  If "$(_WAITTIMEEXPIRED)" EQ "TRUE"
    Echo Er: Timed out waiting for ACK to Message
  If "$(_WAITTIMEEXPIRED)" EQ "TRUE"
    Goto SendEnqForReply
  
  Goto WaitForAckToRec

:GotAckToRec

  ; Send an EOT character.
  Call SENDEOT

Return
; ************************************************************************

; ************************************************************************
;  AbortSending
;   The script reaches this point when it encounters an error sending the
;   current record. (e.g. Maximum retries have been reached). At this
;   point we send an EOT and exit from the script.
; ************************************************************************
:AbortSending

  ; Send an EOT character.
  Call SENDEOT

  ; Abort current process
Exit
; ************************************************************************

; ************************************************************************
;  HandleDLE
;   The script reaches this point when the PBX sends us a DLE character
;   requesting an interruption in the data link.
;   (ReceivedRec will contain the DLE character)
; ************************************************************************
:HandleDLE

  ; We have received a DLE character. The next character will tell us what
  ; sort of escape it is. ( '|' = request to stop transmission, 
  ; '<' = request for permission to send ). Either way we should stop 
  ; sending and send an EOT character to release the data link.
  
  ; Read DLE sequence and echo it to comms display.
  ReadFromPort 1 1
  
  Assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"
  Echo Rx: $(ReceivedRec)
  
  ; Send the EOT character
  Call SENDEOT
  
  ; Abort our current process.
Exit
; ************************************************************************

; ************************************************************************
;  HandleEnquiry
;   The script reaches this point when the PBX sends us a '1' character
;   whilst we are waiting for an acknowledgement to our Enquiry sequence.
;   (ReceivedRec will contain "1")
; ************************************************************************
:HandleEnquiry

  ; We have received a '1' from the PBX as the start of an Enquiry. We 
  ; need to receive the rest of the Enquiry sequence and drop out of the
  ; send.
  
  ; Receive the '!'
  ReadFromPort 1 1
  Assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"

  ; Receive the ENQ
  ReadFromPort 1 1
  Assign ReceivedRec "$(ReceivedRec)" + "$(_PORTCHARS)"
  
  ; Echo to screen
  Echo Rx: $(ReceivedRec)
  
  StartWaitTimer 10

:HE_WaitForENQ
  ; Wait for a new Enquiry.
  ReadFromPort 1 2

  ; If it's a 1 then we need to handle an enquiry.
  If "$(_PORTCHARS)" EQ "1"
    Assign ReceivedRec "1"
  If "$(_PORTCHARS)" EQ "1"
    Goto ReceiveEnquiry

  ; If it's an STX then we should record it and goto ReceiveRecord
  If "$(_PORTCHARS)" EQ "<#2>"
    Assign ReceivedRec "<#2>"
  If "$(_PORTCHARS)" EQ "<#2>"
    Goto ReceiveRecord

  ; If it's an ENQ then we have failed to respond to a message 
  ; (probably because it was lost) so we'll send a NAK.
  If "$(_PORTCHARS)" EQ "<#5>"
    Echo Rx: $(_PORTCHARS)
  If "$(_PORTCHARS)" EQ "<#5>"
    Call SENDNAK

  If "$(_WAITTIMEEXPIRED)" EQ "TRUE"
    Goto HE_Done

  Goto HE_WaitForENQ

:HE_Done
Exit  
; ************************************************************************

; ************************************************************************
;  SENDENQUIRY
;   Sends the enquiry sequence 1!<ENQ> (#49 #33 #5) out of the port and 
;   echoes it to the communications display.
; ************************************************************************
:SENDENQUIRY

  Send 1!<#5>
  Echo Tx: 1!<#5>

Return
; ************************************************************************

; ************************************************************************
;  SENDEOT
;   Sends an EOT (#4) character out of the port and echoes it to the
;   communications display.
; ************************************************************************
:SENDEOT

  Send <#4>
  Echo Tx: <#4>

Return
; ************************************************************************

; ************************************************************************
;  SENDENQ
;   Sends an Enq (#5) character out of the port and echoes it to the
;   communications display.
; ************************************************************************
:SENDENQ

  Send <#5>
  Echo Tx: <#5>

Return
; ************************************************************************

; ************************************************************************
;  SENDACK
;   Sends an Ack (#6) character out of the port and echoes it to the
;   communications display.
; ************************************************************************
:SENDACK

  Send <#6>
  Echo Tx: <#6>

Return
; ************************************************************************

; ************************************************************************
;  SENDNAK
;   Sends an NAK (#21) character out of the port and echoes it to the
;   communications display.
; ************************************************************************
:SENDNAK

  Send <#21>
  Echo Tx: <#21>

Return
; ************************************************************************

; ************************************************************************
;  IgnoreRecord
;   Flag that the processing was successful and exit the script.
; ************************************************************************
:IgnoreRecord

  FLAGPROCESSED OK

Exit
; ************************************************************************

; ************************************************************************
;  HandleOKAndExit
;   Flag that the processing was successful and exit the script.
; ************************************************************************
:HandleOKAndExit

  FLAGPROCESSED OK

Exit
; ************************************************************************

; ************************************************************************
;  HandleFailedAndExit
;   Flag that the processing has failed and exit the script.
; ************************************************************************
:HandleFailedAndExit

  FLAGPROCESSED FAIL

Exit
; ************************************************************************
