; Coded For: 6.0.0.0
; Script Version: 50.0.6.0
; ************************************************************************
;
;  This is the HI configuration script for interfacing to an Alcatel
;  exchange in GPIN mode via serial when TigerTMS is controlling the
;  GPIN allocation.
;
;                                                              AU-20110421
;
;  Modifications - AU - 2017-10-05 - 50.0.6.0
;	* Added check to stop Modification messages being sent for checked
;	  out rooms
;
;  Modifications - AU - 2015-07-09 - 50.0.5.0
;	* Modified all sections so we only send events with the PIN facility
;
;  Modifications - AU - 2015-07-07 - 50.0.4.0
;	* Removed port restart sequence which is not valid on serial
;
;  Modifications - AU - 2013-10-31 - 50.0.3.0
;	* Added additional reply information for Accepted Allocation
;
;  Modifications - AU - 2013-10-31 - 50.0.2.0
;	* Resolved issue with Minibar messages
;
;  Modifications - AU - 2013-10-17 - 50.0.0.1
;	* Updated to utilise V50 specific features
;
; ************************************************************************
;                     Copyright © 2013, TigerTMS Ltd.                     
; ************************************************************************
;
define ReceivedRec
define RecType
define SendRec
define WorkVal
;
define f_GotReply
define f_ReplyExtn
define f_ReplyType1
define f_ReplyType2
define f_Sending
define f_SendLabel
define f_UseDDI
define f_WaitingForReply
;
define s_CloseDOD
define s_DoDDI
define s_DoDND
define s_DoMessageWaiting
define s_DoMinibar
define s_DoVoicemail
define s_DoWakeups
define s_ExtnLength
define s_LocalDOD
define s_NationalDOD
define s_OpenDOD
;
define in_Action
define in_BCC
define in_CRString
define in_DataType
define in_Dummy
define in_Extn
define in_MBCode
define in_MBItem
define in_MBQuantity
define in_MWStatus
define in_PRPin
define in_PRType
define in_PW
define in_Reason
define in_RSMaidID
define in_RSStatus
define in_WKActDate
define in_WKCode
define in_WKOriginator
define in_WKTime
;
; ************************************************************************
;  INIT
;   This label is called at program startup.
:INIT

//	OPT: Set the Extension Length
	Assign s_ExtnLength "8"

//	OPT: Set whether we want to do DDI events
	Assign s_DoDDI "TRUE"

//	OPT: Set whether we want to do DND events
	Assign s_DoDND "TRUE"

//	OPT: Set whether we want to do Message Waiting events
	Assign s_DoMessageWaiting "FALSE"

//	OPT: Set whether Alcatel Voicemail is integrated
	Assign s_DoVoicemail "TRUE"

//	OPT: Set whether we want to do Wakeup events
	Assign s_DoWakeups "TRUE"

//	OPT: Set whether we want to handle incoming Minibar events
	Assign s_DoMinibar "TRUE"

//	OPT: Set the DOD Value for Barred
	Assign s_CloseDOD "20"

//	OPT: Set the DOD Value for Unbarred
	Assign s_OpenDOD "10"

//	OPT: Set the DOD Value for Local
	Assign s_LocalDOD "10"

//	OPT: Set the DOD Value for National
	Assign s_NationalDOD "10"

	OpenPort

Exit
; ************************************************************************


; ************************************************************************
;  PORT_OPENED
;    This label is called when an IP Connection is established.
:PORT_OPENED

Exit
; ************************************************************************


; ************************************************************************
;  SHUTDOWN
;    This label is called when the program is terminated.
:SHUTDOWN

Exit
; ************************************************************************


; ************************************************************************
;  CallRecord
;   This label is executed by the program when we have a Call Record to
;   send.
:CallRecord

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  RoomStatus
;   This label is executed by the program when we have a Room Status
;   event to send.
:RoomStatus

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  Minibar
;   This label is executed by the program when we have a Minibar Event
;   to send.
:Minibar

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  MessageWaiting
;   This label is executed by the program when we have a Message Waiting
;   event to send.
:MessageWaiting

	if "$(s_DoMessageWaiting)" NE "TRUE"
		Goto IgnoreRecord

	ContainsStr "PIN" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	if "$(_EV_PIN)" EQ ""
		Goto IgnoreRecord

	QueryRoomOccupied "$(_EV_EXTNNUMBER)"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	Assign WorkVal "0"
	if "$(_EV_MWSTATE)" EQ "TRUE"
		Assign WorkVal "1"

	Assign SendRec "M<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP> 000000000000000000000                   $(WorkVal)      "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  WakeupCall
;   This label is executed by the program when we have a Wakeup Call
;   event to send.
:WakeupCall

	if "$(s_DoWakeups)" NE "TRUE"
		Goto IgnoreRecord

	ContainsStr "PIN" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	if "$(_EV_PIN)" EQ ""
		Goto IgnoreRecord

	if "$(_EV_WKACTION)" EQ "CLEARALL"
		Assign WorkVal "00000"
	if "$(_EV_WKACTION)" EQ "CLEAR"
		Assign WorkVal "00000"
	if "$(_EV_WKACTION)" EQ "SET"
		Assign WorkVal "<_EV_WKTIME:TIME:4:HHMM> "

	Assign SendRec "M<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP> 000000000000000000000                    $(WorkVal) "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  Checkin
;   This label is executed by the program when we have a Check In event
;   to send.
:Checkin

	ContainsStr "PIN" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	if "$(_EV_PIN)" EQ ""
		Goto IgnoreRecord

//	Check out the PIN
	Assign SendRec "D<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

	Sleep 1000

//	Check out the Extension
	Assign SendRec "D<_EV_EXTNNUMBER:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

	Sleep 1000

//	Check in the PIN
	Assign SendRec "A<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP> <_EV_NAMEDISPLAY:TEXT:20:UC,AN,LJ,SP><_EV_LANGCODE:NUMBER:1:ZP>        <s_OpenDOD:TEXT:2:RJ,SP>                "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "I"
	Assign f_ReplyType2 "J"
	Assign f_ReplyExtn "$(_EV_PIN)"
	Call SendRecord

	Sleep 1000

//	Allocate the PIN to the Extension
	Assign SendRec "H<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP><_EV_EXTNNUMBER:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "A"
	Assign f_ReplyType2 "B"
	Assign f_ReplyExtn "$(_EV_PIN)"
	Call SendRecord

//	Check if Alcatel Voicemail is integrated at this site
	if "$(s_DoVoicemail)" NE "TRUE"
		Goto HandleOKAndExit

	Sleep 1000

//	Check if this Extension is the Primary
	ContainsStr "VOICE" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	Assign WorkVal ""
	if "$(_G_RESULT)" EQ "TRUE"
		Assign WorkVal "1"

	Assign SendRec "F<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP>P<WorkVal:TEXT:1:LJ,SP>     "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  Checkout
;   This label is executed by the program when we have a Check Out event
;   to send.
:Checkout

	ContainsStr "PIN" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

//	Check out the Extension
	Assign SendRec "D<_EV_EXTNNUMBER:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

	if "$(_EV_PIN)" EQ ""
		Goto IgnoreRecord

	Sleep 1000

//	Check out the PIN
	Assign SendRec "D<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  ClassOfService
;   This label is executed by the program when we have a Class of Service
;   event to send.
:ClassOfService

	ContainsStr "PIN" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	if "$(_EV_PIN)" EQ ""
		Goto IgnoreRecord

	QueryRoomOccupied "$(_EV_EXTNNUMBER)"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	Assign WorkVal "$(s_CloseDOD)"
	if "$(_EV_COSALLOWOUTGOING)" EQ "TRUE"
		Assign WorkVal "$(s_OpenDOD)"
	if "$(_EV_COSALLOWOUTGOING)" NE "TRUE"
		Assign WorkVal "$(s_CloseDOD)"
	if "$(_EV_COSCOVERAGEPATH)" EQ "0"
		Assign WorkVal "$(s_CloseDOD)"
	if "$(_EV_COSCOVERAGEPATH)" EQ "1"
		Assign WorkVal "$(s_LocalDOD)"
	if "$(_EV_COSCOVERAGEPATH)" EQ "2"
		Assign WorkVal "$(s_NationalDOD)"
	if "$(_EV_COSCOVERAGEPATH)" EQ "3"
		Assign WorkVal "$(s_OpenDOD)"

	Assign SendRec "M<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP> 0000000000000000000000       <WorkVal:TEXT:2:RJ,SP>                "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  RoomUpdate
;   This label is executed by the program when we have a Room Update
;   event to send.
:RoomUpdate

	ContainsStr "PIN" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	if "$(_EV_PIN)" EQ ""
		Goto IgnoreRecord

	QueryRoomOccupied "$(_EV_EXTNNUMBER)"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	Assign SendRec "M<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP> <_EV_NAMEDISPLAY:TEXT:20:UC,AN,LJ,SP><_EV_LANGCODE:NUMBER:1:ZP>                          "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  BudgetLimit
;   This label is executed by the program when we have a Budget Limit
;   event to send.
:BudgetLimit

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  RoomTransfer
;   This label is executed by the program when we have a Room Transfer
;   event to send.
:RoomTransfer

	ContainsStr "PIN" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	if "$(_EV_PIN)" EQ ""
		Goto IgnoreRecord

	Assign SendRec "H<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP><_EV_TRDESTEXTNNUMBER:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "A"
	Assign f_ReplyType2 "B"
	Assign f_ReplyExtn "$(_EV_PIN)"
	Call SendRecord

	Sleep 1000

//	Checkout the Source Extension
	Assign SendRec "D<_EV_EXTNNUMBER:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  ExtraGuest
;   This label is executed by the program when we have an Extra Guest
;   event to send.
:ExtraGuest

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  DoNotDisturb
;   This label is executed by the program when we have a do not disturb
;   event to send.
:DoNotDisturb

	if "$(s_DoDND)" NE "TRUE"
		Goto IgnoreRecord

	ContainsStr "PIN" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

        if "$(_EV_PIN)" EQ ""
	        Goto IgnoreRecord

	QueryRoomOccupied "$(_EV_EXTNNUMBER)"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	Assign WorkVal "0"
	if "$(_EV_DNDACTION)" EQ "DONOTDISTURB"
		Assign WorkVal "2"

	Assign SendRec "M<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP> 0000000000000000000000                        <WorkVal:TEXT:1:LJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  PIN
;   This label is executed by the program when we have a pin event to send.
:PIN

	ContainsStr "PIN" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	if "$(_EV_PIN)" EQ ""
		Goto IgnoreRecord

	if "$(_EV_PINACTION)" EQ "SET"
		Goto PIN_Set
	if "$(_EV_PINACTION)" EQ "CLEAR"
		Goto PIN_Clear

	Echo If: Unknown _EV_PINACTION: "$(_EV_PINACTION)" for Event ID $(_EV_ID).
	Goto IgnoreRecord

:PIN_Set

//	Check out the PIN
	Assign SendRec "D<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

	Sleep 1000

//	Check in the PIN
	Assign SendRec "A<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP> <_EV_NAMEDISPLAY:TEXT:20:UC,AN,LJ,SP><_EV_LANGCODE:NUMBER:1:ZP>        <s_OpenDOD:TEXT:2:RJ,SP>                "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "I"
	Assign f_ReplyType2 "J"
	Assign f_ReplyExtn "$(_EV_PIN)"
	Call SendRecord

	Sleep 1000

//	Allocate the PIN to the Extension
	Assign SendRec "H<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP><_EV_EXTNNUMBER:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "A"
	Assign f_ReplyType2 "B"
	Assign f_ReplyExtn "$(_EV_PIN)"
	Call SendRecord

//	Check if Alcatel Voicemail is integrated at this site
	if "$(s_DoVoicemail)" NE "TRUE"
		Goto HandleOKAndExit

	Sleep 1000

//	Check if this Extension is the Primary
	ContainsStr "VOICE" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	Assign WorkVal ""
	if "$(_G_RESULT)" EQ "TRUE"
		Assign WorkVal "1"

	Assign SendRec "F<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP>P<WorkVal:TEXT:1:LJ,SP>     "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit

:PIN_Clear

//	Check out the PIN
	Assign SendRec "D<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  DDI
;   This label is executed by the program when we have a DDI event to send.
:DDI

	if "$(s_DoDDI)" NE "TRUE"
		Goto IgnoreRecord

	ContainsStr "DDI" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	if "$(_EV_DDI)" EQ ""
		Goto IgnoreRecord

	if "$(_EV_DDIACTION)" EQ "SET"
		Goto DDI_Set
	if "$(_EV_DDIACTION)" EQ "CLEAR"
		Goto DDI_Clear

	Echo If: Unknown _EV_DDIACTION: "$(_EV_DDIACTION)" for Event ID $(_EV_ID).
	Goto IgnoreRecord

:DDI_Set

	Assign f_UseDDI "TRUE"

//	Check out the new PIN
	Assign SendRec "D<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

//	Check in the PIN
	Assign SendRec "A<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP> <_EV_NAMEDISPLAY:TEXT:20:UC,AN,LJ,SP><_EV_LANGCODE:NUMBER:1:ZP>        <s_OpenDOD:TEXT:2:RJ,SP>                "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "I"
	Assign f_ReplyType2 "J"
	Assign f_ReplyExtn "$(_EV_DDI)"
	Call SendRecord

	Sleep 1000

//	Allocate the PIN to the Extension
	Assign SendRec "H<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP><_EV_EXTNNUMBER:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "A"
	Assign f_ReplyType2 "B"
	Assign f_ReplyExtn "$(_EV_DDI)"
	Call SendRecord

//	Check if Alcatel Voicemail is integrated at this site
	if "$(s_DoVoicemail)" NE "TRUE"
		Goto HandleOKAndExit

	Sleep 1000

//	Check if this Extension is the Primary
	ContainsStr "VOICE" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	Assign WorkVal ""
	if "$(_G_RESULT)" EQ "TRUE"
		Assign WorkVal "1"

	Assign SendRec "F<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP>P<WorkVal:TEXT:1:LJ,SP>     "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

	Assign f_UseDDI "FALSE"

Goto HandleOKAndExit

:DDI_Clear

	Assign f_UseDDI "TRUE"

//	Check out the old PIN
	Assign SendRec "D<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

	Assign f_UseDDI "FALSE"

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  GuestInfo
;   This label is executed by the program when we have a Guest Information
;   event to send.
:GuestInfo

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  BillEnquiry
;   This label is executed by the program when we have a Bill Enquiry
;   event to send.
:BillEnquiry

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  ExpressCheckout
;   This label is executed by the program when we have an Express Checkout
;   event to send.
:ExpressCheckout

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  BillResponse
;   This label is executed by the program when we have a Bill Response
;   event to send.
:BillResponse

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  ExpressCheckoutResponse
;   This label is executed by the program when we have an Express Checkout
;   Response event to send.
:ExpressCheckoutResponse

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  TVRights
;   This label is executed by the program when we have a Television Rights
;   event to send.
:TVRights

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  CallPackage
;   This label is executed by the program when we have a Call Package
;   event to send.
:CallPackage

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  ExternalMessage
;   This label is executed by the program when we have an External
;   Message event to send.
:ExternalMessage

Goto IgnoreRecord
; ************************************************************************


; ************************************************************************
;  GenericPassthrough
;   This label is executed by the program when we have a Generic
;   Passthrough event to send.
:GenericPassthrough

//	Check if this Extension is the Primary
	ContainsStr "VOICE" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	if "$(_G_RESULT)" NE "TRUE"
		Goto IgnoreRecord

	if "$(_EV_GPTMSGTYPE)" EQ "REFRESH_INIT"
		Goto GPT_Init
	if "$(_EV_GPTMSGTYPE)" EQ "REFRESH_UNASSIGN"
		Goto GPT_Unassign

	Goto IgnoreRecord

:GPT_Unassign

//	PIN = _EV_GPTCFGFIELD_1

	if "$(_EV_GPTCFGFIELD_1)" EQ ""
		Goto GPT_Unassign_Extn

	Assign SendRec "D<_EV_GPTCFGFIELD_1:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

:GPT_Unassign_Extn

//	Extension = _EV_GPTCFGFIELD_2

	if "$(_EV_GPTCFGFIELD_2)" EQ ""
		Goto GPT_End

	Assign SendRec "D<_EV_GPTCFGFIELD_2:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

	Goto GPT_End

:GPT_Init

	Assign WorkVal ""
	Assign SendRec "Z<WorkVal:TEXT:$(s_ExtnLength):RJ,SP>P"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

	Goto HandleOKAndExit

:GPT_End

Goto HandleOKAndExit
; ************************************************************************


; ************************************************************************
;  PeriodicCheck
;   This label is executed periodically by the program.
:PeriodicCheck

	if "$(f_Sending)" EQ "TRUE"
		Return

Exit
; ************************************************************************


; ************************************************************************
;  CheckIncoming
;   This label is executed by the program periodically to check incoming
;   messeges.
:CheckIncoming

	Assign f_Sending "FALSE"

	ReadFromPort 1 1

	if "$(_PORTCHARS)" EQ "<#2>"
		Assign ReceivedRec "<#2>"
	if "$(_PORTCHARS)" EQ "<#2>"
		Goto ReceiveRecord

	if "$(_PORTCHARS)" EQ "<#36>"
		Goto HBRECORD

	if "$(_PORTCHARS)" NE ""
		Echo Rx: $(_PORTCHARS)

Exit
; ************************************************************************


; ************************************************************************
;  ReceiveRecord
;   This label is called when we have received an STX within the
;   CheckIncoming or SendRecord labels.
:ReceiveRecord

	Assign ReceivedRec "<#2>"

	ReadFromPort 1 1

	if "$(_PORTCHARS)" NE ""
		Assign ReceivedRec "$(ReceivedRec)$(_PORTCHARS)"

	if "$(_PORTCHARS)" EQ ""
		Goto ReceiveRecord

	Assign RecType "$(_PORTCHARS)"

	if "$(_PORTCHARS)" EQ "<#36>"
		Goto HBRECORD
	if "$(_PORTCHARS)" EQ "J"
		Goto JRECORD
	if "$(_PORTCHARS)" EQ "K"
		Goto KRECORD

:ReceiveRecord_ReadNextChar

	ReadFromPort 1 1

	if "$(_PORTCHARS)" NE ""
		Assign ReceivedRec "$(ReceivedRec)$(_PORTCHARS)"

	if "$(_PORTCHARS)" EQ "<#3>"
		Goto ReceiveRecord_FinishedReceiving

Goto ReceiveRecord_ReadNextChar

:ReceiveRecord_FinishedReceiving

	Echo Rx: $(ReceivedRec)
	Send <#6>
	Echo Tx: <#6>

	if "$(RecType)" EQ ""
		Goto ReceiveRecord_QuitReceiving
	if "$(RecType)" EQ "A"
		Goto ReceiveRecord_QuitReceiving
	if "$(RecType)" EQ "D"
		Goto ReceiveRecord_QuitReceiving
	if "$(RecType)" EQ "H"
		Goto ReceiveRecord_QuitReceiving
	if "$(RecType)" EQ "M"
		Goto ReceiveRecord_QuitReceiving
	if "$(RecType)" EQ "T"
		Goto ReceiveRecord_QuitReceiving

	if "$(RecType)" EQ "C"
		Call CRECORD
	if "$(RecType)" EQ "F"
		Call FRECORD
	if "$(RecType)" EQ "P"
		Call PRECORD
	if "$(RecType)" EQ "R"
		Call RRECORD
	if "$(RecType)" EQ "U"
		Call URECORD

	Assign _G_IN_RECORD "$(ReceivedRec)"
	ParseInRecord

	if "$(_G_IN_RECORDPARSEERROR)" EQ "TRUE"
		Echo Error with Received Record - Record ignored
	if "$(_G_IN_RECORDPARSEERROR)" EQ "TRUE"
		Goto ReceiveRecord_QuitReceiving

	if "$(RecType)" EQ "C"
		Call HandleCRecord
	if "$(RecType)" EQ "F"
		Call HandleFRecord
	if "$(RecType)" EQ "J"
		Call HandleJRecord
	if "$(RecType)" EQ "K"
		Call HandleKRecord
	if "$(RecType)" EQ "P"
		Call HandlePRecord
	if "$(RecType)" EQ "R"
		Call HandleRRecord
	if "$(RecType)" EQ "U"
		Call HandleURecord

:ReceiveRecord_QuitReceiving

	if "$(f_Sending)" EQ "TRUE"
		Return

Exit
; ************************************************************************


; ************************************************************************
;  JustSendRecord
;   This label is called when we have a record that we need to send to the
;   client when we do not need a response.
:JustSendRecord

	Assign f_ReplyExtn "0"
	Assign f_ReplyType1 "0"
	Assign f_ReplyType2 "0"

	Assign f_SendLabel "JustSendRecord"
	Assign f_Sending "TRUE"

	Send $(SendRec)
	Echo Tx: $(SendRec)

	StartWaitTimer 25

:JustSendRecord_WaitForACK

	Sleep 10

	ReadFromPort 1 1

	if "$(_WAITTIMEEXPIRED)" EQ "TRUE"
		Goto SendError

	if "$(_PORTCHARS)" EQ ""
		Goto JustSendRecord_WaitForACK

	if "$(_PORTCHARS)" EQ "<#6>"
		Echo Rx: <#6>
	if "$(_PORTCHARS)" EQ "<#6>"
		Goto JustSendRecord_GotACK

	if "$(_PORTCHARS)" EQ "<#21>"
		Echo Rx: <#21>
	if "$(_PORTCHARS)" EQ "<#21>"
		Sleep 3000
	if "$(_PORTCHARS)" EQ "<#21>"
		Goto JustSendRecord

	if "$(_PORTCHARS)" EQ "<#2>"
		Assign ReceivedRec "<#2>"
	if "$(_PORTCHARS)" EQ "<#2>"
		Call ReceiveRecord

	Goto JustSendRecord_WaitForACK

:JustSendRecord_GotACK

	Assign f_Sending "FALSE"

Return
; ************************************************************************


; ************************************************************************
;  SendRecord
;   This label is called when we have a record that we need to send to the
;   client.
:SendRecord

	Assign f_SendLabel "SendRecord"
	Assign f_Sending "TRUE"

	Send $(SendRec)
	Echo Tx: $(SendRec)

	StartWaitTimer2 25

:SendRecord_WaitForACK

	Sleep 10

	ReadFromPort 1 1

	if "$(_WAITTIMEEXPIRED2)" EQ "TRUE"
		Goto SendError

	if "$(_PORTCHARS)" EQ ""
		Goto SendRecord_WaitForACK

	if "$(_PORTCHARS)" EQ "<#6>"
		Echo Rx: <#6>
	if "$(_PORTCHARS)" EQ "<#6>"
		Goto SendRecord_GotACK

	if "$(_PORTCHARS)" EQ "<#21>"
		Echo Rx: <#21>
	if "$(_PORTCHARS)" EQ "<#21>"
		Sleep 3000
	if "$(_PORTCHARS)" EQ "<#21>"
		Goto SendRecord

	if "$(_PORTCHARS)" EQ "<#2>"
		Assign ReceivedRec "<#2>"
	if "$(_PORTCHARS)" EQ "<#2>"
		Call ReceiveRecord

	Goto SendRecord_WaitForACK

:SendRecord_GotACK

	Assign f_WaitingForReply "TRUE"
	Assign f_GotReply "FALSE"

	StartWaitTimer2 120

:SendRecord_WaitForReply

	ReadFromPort 1 1

	if "$(_WAITTIMEEXPIRED2)" EQ "TRUE"
		Goto SendError

	if "$(_PORTCHARS)" EQ ""
		Goto SendRecord_WaitForReply

	if "$(_PORTCHARS)" EQ "<#2>"
		Assign ReceivedRec "<#2>"
	if "$(_PORTCHARS)" EQ "<#2>"
		Call ReceiveRecord

	if "$(f_GotReply)" EQ "TRUE"
		Goto SendRecord_GotReply

	Goto SendRecord_WaitForReply

:SendRecord_GotReply

	Assign f_Sending "FALSE"
	Assign f_WaitingForReply "FALSE"
	Assign f_GotReply "FALSE"

Return
; ************************************************************************


; ************************************************************************
;  SendError
;   This label is called when we have failed to send a record
:SendError

	Echo If: Timeout waiting for ACK or a reply, restarting port.

	ClosePort
	Sleep 5000
	OpenPort

	Echo If: Port Reopened

Exit
; ************************************************************************


; ************************************************************************
;  CRECORD
;   Setup the expected format for receiving a C record (Room Status)
:CRECORD

	if "$(s_ExtnLength)" EQ "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>C<in_Extn:TEXT:8:RJ,SP><in_RSMaidID:TEXT:4:RJ,SP><in_RSStatus:TEXT:1:LJ,SP><in_BCC:TEXT:2:RJ,ZP><#3>"
	if "$(s_ExtnLength)" NE "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>C<in_Extn:TEXT:5:RJ,SP><in_RSMaidID:TEXT:4:RJ,SP><in_RSStatus:TEXT:1:LJ,SP><in_BCC:TEXT:2:RJ,ZP><#3>"

Return
; ************************************************************************


; ************************************************************************
;  FRECORD
;   Setup the expected format for receiving a F record (Message Waiting)
:FRECORD

	if "$(s_ExtnLength)" EQ "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>F<in_Extn:TEXT:8:RJ,SP>M<in_MWStatus:TEXT:1:SP><in_Dummy:TEXT:8:RJ,SP><in_BCC:TEXT:2:RJ,ZP><#3>"
	if "$(s_ExtnLength)" NE "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>F<in_Extn:TEXT:5:RJ,SP>M<in_MWStatus:TEXT:1:SP><in_Dummy:TEXT:5:RJ,SP><in_BCC:TEXT:2:RJ,ZP><#3>"

Return
; ************************************************************************


; ************************************************************************
;  HBRECORD
;   Setup the expected format for receiving an HB record (Message Waiting)
:HBRECORD

	ReadFromPort 5 1
	Assign ReceivedRec "$(ReceivedRec)$(_PORTCHARS)"

	Echo Rx: $(ReceivedRec)

	if "<ReceivedRec:TEXT:1:LJ,SP>" NE "<#2>"
		Echo Db: Record with no STX in ReceiveRecord_FinishedReceiving

	Sleep 500

Goto PeriodicCheck
; ************************************************************************


; ************************************************************************
;  JRECORD
;   Setup the expected format for receiving a J record (Call Record)
:JRECORD

	if "$(s_ExtnLength)" EQ "8"
		ReadFromPort 72 1
	if "$(s_ExtnLength)" NE "8"
		ReadFromPort 66 1

	Assign ReceivedRec "$(ReceivedRec)$(_PORTCHARS)"

	AssignAsIs _G_IN_RECORDFORMAT "<#2><in_CRString:TEXT:500:><#3>"

Goto ReceiveRecord_FinishedReceiving
; ************************************************************************


; ************************************************************************
;  KRECORD
;   Setup the expected format for receiving a K record (Call Record)
:KRECORD

	ReadFromPort 249 1
	Assign ReceivedRec "$(ReceivedRec)$(_PORTCHARS)"

	AssignAsIs _G_IN_RECORDFORMAT "<#2><in_CRString:TEXT:500:><#3>"

Goto ReceiveRecord_FinishedReceiving
; ************************************************************************


; ************************************************************************
;  PRECORD
;   Setup the expected format for receiving a P record (Data / Information)
:PRECORD

	if "$(s_ExtnLength)" EQ "8"
		CopySubStr "$(ReceivedRec)" "11" "1"
	if "$(s_ExtnLength)" NE "8"
		CopySubStr "$(ReceivedRec)" "8" "1"

	if "$(_G_RESULT)" EQ "W"
		Goto PRECORD_WakeupCall

	Assign in_DataType "MB"

	if "$(s_ExtnLength)" EQ "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>P<in_Extn:TEXT:8:RJ,SP><in_MBCode:TEXT:5:RJ,SP><in_MBItem:TEXT:5:>*<in_MBQuantity:TEXT:5:> <in_BCC:TEXT:2:RJ,ZP><#3>"
	if "$(s_ExtnLength)" NE "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>P<in_Extn:TEXT:5:RJ,SP><in_MBCode:TEXT:5:RJ,SP><in_MBItem:TEXT:5:>*<in_MBQuantity:TEXT:5:> <in_BCC:TEXT:2:RJ,ZP><#3>"

Return

:PRECORD_WakeupCall

	Assign in_DataType "WK"

	if "$(s_ExtnLength)" EQ "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>P<in_Extn:TEXT:8:RJ,SP>W  <in_WKCode:TEXT:1:LJ,SP> <in_WKActDate:TEXT:10:RJ,SP><in_WKOriginator:TEXT:5:LJ,SP><in_WKTime:TIME:4:HHMM> <in_BCC:TEXT:2:RJ,ZP><#3>"
	if "$(s_ExtnLength)" NE "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>P<in_Extn:TEXT:5:RJ,SP>W  <in_WKCode:TEXT:1:LJ,SP> <in_WKActDate:TEXT:10:RJ,SP><in_WKOriginator:TEXT:5:LJ,SP><in_WKTime:TIME:4:HHMM> <in_BCC:TEXT:2:RJ,ZP><#3>"

Return
; ************************************************************************


; ************************************************************************
;  RRECORD
;   Setup the expected format for receiving a R record (Reply)
:RRECORD

	if "$(s_ExtnLength)" EQ "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>R<in_Extn:TEXT:8:RJ,SP><in_PW:TEXT:4:RJ,SP><in_Action:TEXT:1:SP><in_Reason:TEXT:1:SP><in_BCC:TEXT:2:RJ,ZP><#3>"
	if "$(s_ExtnLength)" NE "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>R<in_Extn:TEXT:5:RJ,SP><in_PW:TEXT:4:RJ,SP><in_Action:TEXT:1:SP><in_Reason:TEXT:1:SP><in_BCC:TEXT:2:RJ,ZP><#3>"

Return
; ************************************************************************


; ************************************************************************
; URECORD
;  Setup the expected format for receiving a Reinit record (Refresh)
:URECORD

	if "$(s_ExtnLength)" EQ "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>U<in_PRPin:TEXT:8:RJ,SP><in_PRType:TEXT:1:SP><in_Extn:TEXT:8:RJ,SP><in_PW:TEXT:4:RJ,SP><in_BCC:TEXT:2:RJ,ZP><#3>"
	if "$(s_ExtnLength)" NE "8"
		AssignAsIs _G_IN_RECORDFORMAT "<#2>U<in_PRPin:TEXT:5:RJ,SP><in_PRType:TEXT:1:SP><in_Extn:TEXT:5:RJ,SP><in_PW:TEXT:4:RJ,SP><in_BCC:TEXT:2:RJ,ZP><#3>"        

Return
; ************************************************************************


; ************************************************************************
;  HandleCRecord
;    This label is called when we have a C record to handle
:HandleCRecord

	if "$(in_RSStatus)" NE ""
		CreateRoomStatus "$(in_Extn)" "$(in_RSStatus)"

Return
; ************************************************************************


; ************************************************************************
;  HandleFRecord
;    This label is called when we have an F record to handle
:HandleFRecord

	QueryRoomForPIN "$(in_Extn)"
	if "$(_G_RESULT)" EQ ""
		Echo Er: Unknown GPIN $(in_Extn) on incoming Message Waiting event.
	if "$(_G_RESULT)" EQ ""
		Return

	if "$(in_MWStatus)" EQ "0"
		CreateMessageWaiting "$(_G_RESULT)" "FALSE"
	if "$(in_MWStatus)" NE "0"
		CreateMessageWaiting "$(_G_RESULT)" "TRUE"

Return
; ************************************************************************


; ************************************************************************
;  HandleJRecord
;    This label is called when we have a J record to handle
:HandleJRecord

	PassToDataCollection $(in_CRString)

Return
; ************************************************************************


; ************************************************************************
;  HandleKRecord
;    This label is called when we have a K record to handle
:HandleKRecord

	PassToDataCollection $(in_CRString)

Return
; ************************************************************************


; ************************************************************************
;  HandlePRecord
;    This label is called when we have a C record to handle
:HandlePRecord

	if "$(in_DataType)" EQ "MB"
		Goto HandlePRecord_Minibar
	if "$(in_DataType)" EQ "WK"
		Goto HandlePRecord_Wakeup

	Echo If: Unknown in_DataType: "$(in_DataType)".

Return

:HandlePRecord_Minibar

	AssignAsIs _G_IN_RECORDFORMAT "<in_MBQuantity:TEXT:5:LJ,SP>"

	ContainsSTR "#" "$(in_MBQuantity)" "FALSE"
	if "$(_G_RESULT)" EQ "TRUE"
		AssignAsIs _G_IN_RECORDFORMAT "<in_MBQuantity:TEXT:5:>#"

	ContainsSTR "T" "$(in_MBQuantity)" "FALSE"
	if "$(_G_RESULT)" EQ "TRUE"
		AssignAsIs _G_IN_RECORDFORMAT "<in_MBQuantity:TEXT:5:>T"

:CreateMinibarEvent_Parse

	Assign _G_IN_RECORD "<in_MBQuantity:TEXT:5:LJ,SP>"
	ParseInRecord

	if "$(in_MBItem)" EQ ""
		Echo Db: No item number
	if "$(in_MBItem)" EQ ""
		Return

	if "$(in_MBItem)" GT "999"
		Echo Db: No item number
	if "$(in_MBItem)" GT "999"
		Return

	if "$(in_MBQuantity)" EQ ""
		Echo Db: No quantity
	if "$(in_MBQuantity)" EQ ""
		Return

	if "$(in_MBQuantity)" GT "999"
		Echo Db: No quantity
	if "$(in_MBQuantity)" GT "999"
		Return

	CreateMinibar "$(in_Extn)" "0" "$(in_MBItem)" "$(in_MBQuantity)" "0" "Alcatel Minibar"

Return

:HandlePRecord_Wakeup

	if "$(in_WKCode)" EQ "P"
		Echo If: Wakeup Call Set for <in_WKTime:TIME:5:HH:MM> on $(in_Extn).
	if "$(in_WKCode)" EQ "P"
		CreateSetWakeup "$(in_Extn)" "" "<in_WKTime:TIME:4:HHMM>"
	if "$(in_WKCode)" EQ "P"
		Return

	if "$(in_WKCode)" EQ "M"
		Echo If: Wakeup Call Modified for <in_WKTime:TIME:5:HH:MM> on $(in_Extn).
	if "$(in_WKCode)" EQ "M"
		Return

	if "$(in_WKCode)" EQ "C"
		Echo If: Wakeup Call Canceled for <in_WKTime:TIME:5:HH:MM> on $(in_Extn).
	if "$(in_WKCode)" EQ "C"
		CreateClearWakeup "$(in_Extn)" "" "<in_WKTime:TIME:4:HHMM>"
	if "$(in_WKCode)" EQ "C"
		Return

	if "$(in_WKCode)" EQ "R"
		Echo If: Wakeup Call Rejected for <in_WKTime:TIME:5:HH:MM> on $(in_Extn).
	if "$(in_WKCode)" EQ "R"
		CreateWakeupFailed "$(in_Extn)" "" "<_G_NOW:DATE:8:YYYYMMDD>" "<in_WKTime:TIME:4:HHMM>"
	if "$(in_WKCode)" EQ "R"
		Return

	if "$(in_WKCode)" EQ "N"
		Echo If: Wakeup Call Failed for <in_WKTime:TIME:5:HH:MM> on Extension $(in_Extn) - No Answer.
	if "$(in_WKCode)" EQ "N"
		CreateWakeupFailed "$(in_Extn)" "" "<_G_NOW:DATE:8:YYYYMMDD>" "<in_WKTime:TIME:4:HHMM>"
	if "$(in_WKCode)" EQ "N"
		Return

	if "$(in_WKCode)" EQ "O"
		Echo If: Wakeup Call Failed for <in_WKTime:TIME:5:HH:MM> on Extension $(in_Extn) - Line out of Order.
	if "$(in_WKCode)" EQ "O"
		CreateWakeupFailed "$(in_Extn)" "" "<_G_NOW:DATE:8:YYYYMMDD>" "<in_WKTime:TIME:4:HHMM>"
	if "$(in_WKCode)" EQ "O"
		Return

	if "$(in_WKCode)" EQ "B"
		Echo If: Wakeup Call Failed for <in_WKTime:TIME:5:HH:MM> on Extension $(in_Extn) - Busy.
	if "$(in_WKCode)" EQ "B"
		CreateWakeupFailed "$(in_Extn)" "" "<_G_NOW:DATE:8:YYYYMMDD>" "<in_WKTime:TIME:4:HHMM>"
	if "$(in_WKCode)" EQ "B"
		Return

	if "$(in_WKCode)" EQ "A"
		Echo If: Wakeup Call Answered for <in_WKTime:TIME:5:HH:MM> on Extension $(in_Extn).
	if "$(in_WKCode)" EQ "A"
		CreateWakeupDelivered "$(in_Extn)" "" "<_G_NOW:DATE:8:YYYYMMDD>" "<in_WKTime:TIME:4:HHMM>"
	if "$(in_WKCode)" EQ "A"
		Return

	Echo Db: Unknown Wakeup Result "$(in_WKCode)" for $(in_WKTime) on Extension $(in_Extn).

Return
; ************************************************************************


; ************************************************************************
;  HandleRRecord
;    This label is called when we have an R record to handle
:HandleRRecord

	if "$(f_ReplyExtn)" EQ "$(in_Extn)"
		Call HandleRRecord_CheckType

	if "$(in_Action)" EQ "I"
		Echo If: Checkin completed for GPIN $(in_Extn).  Voicemail Password: "$(in_PW)".

	if "$(in_Action)" EQ "J"
		Goto HandleRRecord_RefusedCheckin

	if "$(in_Action)" EQ "A"
		Goto HandleRRecord_AcceptedAllocation

	if "$(in_Action)" EQ "B"
		Goto HandleRRecord_RefusedAllocation

	if "$(in_Action)" EQ "N"
		Goto HandleRRecord_RefusedModification

	if "$(in_Action)" EQ "W"
		Goto HandleRRecord_RefusedAttribution

	if "$(in_Action)" EQ "P"
		Goto HandleRRecord_RefusedCheckout

	Return

:HandleRRecord_CheckType

	if "$(f_ReplyType1)" EQ "$(in_Action)"
		Assign f_GotReply "TRUE"
	if "$(f_ReplyType2)" EQ "$(in_Action)"
		Assign f_GotReply "TRUE"

	if "$(f_GotReply)" EQ "TRUE"
		Echo If: Received extension and type match reply.

	Return

:HandleRRecord_AcceptedAllocation

	if "$(in_Reason)" EQ "O"
		Echo Er: PBX responded - Guest extn out of order.
	if "$(in_Reason)" NE "O"
		Echo If: Allocation completed for GPIN $(in_Extn) to Extension $(_EV_EXTNNUMBER).

	Return

:HandleRRecord_RefusedAllocation

	if "$(in_Reason)" EQ "O"
		Echo Er: PBX responded - Guest extn out of order.

	if "$(in_Reason)" EQ "G"
		Echo Er: PBX responded - Invalid GPIN.

	if "$(in_Reason)" EQ "R"
		Echo Er: PBX responded - Invalid extn number.

	if "$(in_Reason)" EQ "U"
		Echo Er: PBX responded - Unavailable extn number - Under repair.

	if "$(in_Reason)" EQ "Q"
		Echo Er: PBX responded - Database unreachable.

	Return

:HandleRRecord_RefusedCheckout

	if "$(in_Reason)" EQ "G"
		Echo Er: PBX responded - Invalid GPIN.

	if "$(in_Reason)" EQ "L"
		Echo Er: PBX responded - Line in use.

	if "$(in_Reason)" EQ "M"
		Echo Er: PBX responded - Mailbox has messages.

	Return

:HandleRRecord_RefusedAttribution	

	if "$(in_Reason)" EQ "G"
		Echo Er: PBX responded - Invalid GPIN.

	if "$(in_Reason)" EQ "A"
		Echo Er: PBX responded - Unavailable guest number - Not checked in.

	if "$(in_Reason)" EQ "W"
		Echo Er: PBX responded - Mailbox in use.

	if "$(in_Reason)" EQ "V"
		Echo Er: PBX responded - Voicemail unavailable.

	if "$(in_Reason)" EQ "M"
		Echo Er: PBX responded - Not consulted messages.

	if "$(in_Reason)" EQ "Y"
		Echo Er: PBX responded - Out of mailbox number range.

	if "$(in_Reason)" EQ "Z"
		Echo Er: PBX responded - Mailbox already exists.

	if "$(in_Reason)" EQ "J"
		Echo Er: PBX responded - Feature not available.

	if "$(in_Reason)" EQ "J"
		Echo Er: PBX responded - Wrong message.

	if "$(in_Reason)" EQ "J"
		Echo Er: PBX responded - Other.

	if "$(in_Reason)" EQ "Q"
		Echo Er: PBX responded - Database unreachable.

	Return

:HandleRRecord_RefusedCheckin

	if "$(in_Reason)" EQ "A"
		Call HandleRRecord_AlreadyCheckedIn

	if "$(in_Reason)" EQ "G"
		Echo Er: PBX responded - Invalid GPIN.

	if "$(in_Reason)" EQ "E"
		Echo Er: PBX responded - Empty GPIN Database - No GPINs Available.

	if "$(in_Reason)" EQ "N"
		Echo Er: PBX responded - Name too short.

	if "$(in_Reason)" EQ "X"
		Echo Er: PBX responded - Phonebook capacity exceeded.

	if "$(in_Reason)" EQ "Q"
		Echo Er: PBX responded - Database unreachable.

	Return

:HandleRRecord_RefusedModification

	if "$(in_Reason)" EQ "A"
		Call HandleRRecord_NotCheckedIn

	if "$(in_Reason)" EQ "G"
		Echo Er: PBX responded - Invalid GPIN.

	if "$(in_Reason)" EQ "P"
		Echo Er: PBX responded - Password is not available.

	if "$(in_Reason)" EQ "N"
		Echo Er: PBX responded - Name too short.
		
	if "$(in_Reason)" EQ "Q"
		Echo Er: PBX responded - Database unreachable.

	Return

:HandleRRecord_AlreadyCheckedIn

	Echo Er: PBX responded - GPIN already checked in - Actioning.

	if "$(_EV_PIN)" EQ ""
		Return

//	Check out the PIN / DDI
	if "$(f_UseDDI)" EQ "TRUE"
		Assign SendRec "D<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP>"
	if "$(f_UseDDI)" NE "TRUE"
		Assign SendRec "D<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

	Sleep 1000

//	Check in the PIN
	if "$(f_UseDDI)" EQ "TRUE"
		Assign SendRec "A<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP> <_EV_NAMEDISPLAY:TEXT:20:UC,AN,LJ,SP><_EV_LANGCODE:NUMBER:1:ZP>        <s_OpenDOD:TEXT:2:RJ,SP>                "
	if "$(f_UseDDI)" NE "TRUE"
		Assign SendRec "A<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP> <_EV_NAMEDISPLAY:TEXT:20:UC,AN,LJ,SP><_EV_LANGCODE:NUMBER:1:ZP>        <s_OpenDOD:TEXT:2:RJ,SP>                "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "I"
	Assign f_ReplyType2 "J"
	if "$(f_UseDDI)" EQ "TRUE"
		Assign f_ReplyExtn "$(_EV_DDI)"
	if "$(f_UseDDI)" NE "TRUE"
		Assign f_ReplyExtn "$(_EV_PIN)"
	Call SendRecord

	Return

:HandleRRecord_NotCheckedIn

	Echo Er: PBX responded - GPIN not checked in - Actioning.

	if "$(_EV_PIN)" EQ ""
		Return

//	Check in the PIN
	if "$(f_UseDDI)" EQ "TRUE"
		Assign SendRec "A<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP> <_EV_NAMEDISPLAY:TEXT:20:UC,AN,LJ,SP><_EV_LANGCODE:NUMBER:1:ZP>        <s_OpenDOD:TEXT:2:RJ,SP>                "
	if "$(f_UseDDI)" NE "TRUE"
		Assign SendRec "A<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP> <_EV_NAMEDISPLAY:TEXT:20:UC,AN,LJ,SP><_EV_LANGCODE:NUMBER:1:ZP>        <s_OpenDOD:TEXT:2:RJ,SP>                "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "I"
	Assign f_ReplyType2 "J"
	if "$(f_UseDDI)" EQ "TRUE"
		Assign f_ReplyExtn "$(_EV_DDI)"
	if "$(f_UseDDI)" NE "TRUE"
		Assign f_ReplyExtn "$(_EV_PIN)"
	Call SendRecord

	Sleep 1000

//	Allocate the PIN to the Extension
	if "$(f_UseDDI)" EQ "TRUE"
		Assign SendRec "H<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP><_EV_EXTNNUMBER:TEXT:$(s_ExtnLength):RJ,SP>"
	if "$(f_UseDDI)" NE "TRUE"
		Assign SendRec "H<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP><_EV_EXTNNUMBER:TEXT:$(s_ExtnLength):RJ,SP>"
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Assign f_ReplyType1 "A"
	Assign f_ReplyType2 "B"
	if "$(f_UseDDI)" EQ "TRUE"
		Assign f_ReplyExtn "$(_EV_DDI)"
	if "$(f_UseDDI)" NE "TRUE"
		Assign f_ReplyExtn "$(_EV_PIN)"
	Call SendRecord

//	Check if Alcatel Voicemail is integrated at this site
	if "$(s_DoVoicemail)" NE "TRUE"
		Goto HandleOKAndExit

	Sleep 1000

//	Check if this Extension is the Primary
	ContainsStr "VOICE" "<_EV_EXTNFACILITIES:TEXT:255:UC>" "FALSE"
	Assign WorkVal ""
	if "$(_G_RESULT)" EQ "TRUE"
		Assign WorkVal "1"

	if "$(f_UseDDI)" EQ "TRUE"
		Assign SendRec "F<_EV_DDI:TEXT:$(s_ExtnLength):RJ,SP>P<WorkVal:TEXT:1:LJ,SP>     "
	if "$(f_UseDDI)" NE "TRUE"
		Assign SendRec "F<_EV_PIN:TEXT:$(s_ExtnLength):RJ,SP>P<WorkVal:TEXT:1:LJ,SP>     "
	GenerateBCCChar "HEXString" "$(SendRec)"
	Assign SendRec "<#2>$(SendRec)$(_G_BCC)<#3>"
	Call JustSendRecord

Return
; ************************************************************************


; ************************************************************************
;  HandleURecord
;    This label is called when we have a U record to handle
:HandleURecord

	if "$(in_Extn)" EQ ""
		goto HandleURecord_NoData
	if "$(in_PRPin)" EQ ""        
		goto HandleURecord_NoData    

	if "$(in_PRType)" EQ "E"
		Echo Db: Partial Refresh ended
	if "$(in_PRType)" EQ "E"
		CreateGenericPassThrough "$(in_Extn)" "REFRESH_END" "$(in_PRPin)" "$(in_Extn)"

	if "$(in_PRType)" NE "E"
		CreateGenericPassThrough "$(in_Extn)" "REFRESH_MSG" "$(in_PRPin)" "$(in_Extn)"

	Return
    
:HandleURecord_NoData

	Echo Db: Reinit response with blank fields -- PBX's PIN list assumed as empty

Return
; ************************************************************************


; ************************************************************************
;  HandleOKAndExit
;   This label is called when we have completed sending a record and need
;   to flag it as processed to move on to the next event.
:HandleOKAndExit

	FlagProcessed OK
	Sleep 500

Exit
; ************************************************************************


; ************************************************************************
;  IgnoreRecord
;   This label is called when we are not interested in a particular record
;   and need to flag it as processed to move on to the next event.
:IgnoreRecord

	FlagProcessed OK
	Sleep 500

Exit
; ************************************************************************